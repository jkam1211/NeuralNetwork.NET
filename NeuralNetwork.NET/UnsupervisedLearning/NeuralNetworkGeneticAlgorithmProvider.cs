using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using JetBrains.Annotations;
using NeuralNetworkNET.Networks.Implementations;
using NeuralNetworkNET.Networks.PublicAPIs;
using NeuralNetworkNET.UnsupervisedLearning.Misc;

namespace NeuralNetworkNET.UnsupervisedLearning
{
    /// <summary>
    /// A provider that uses a genetic algorithm to breed different species of neural networks to maximize a given fitness function
    /// </summary>
    public sealed class NeuralNetworkGeneticAlgorithmProvider
    {
        #region Public parameters

        /// <summary>
        /// Gets the size of the population for the genetic algorithm
        /// </summary>
        public int PopulationSize => _Population.Length;

        /// <summary>
        /// Gets the mutation probability for each weight in the neural networks
        /// </summary>
        public int WeightsMutationRate { get; }

        /// <summary>
        /// Gets the number of best networks to copy over to each new generation
        /// </summary>
        public int EliteSamples { get; }

        /// <summary>
        /// Gets the function used to evaluate the fitness of every generated network
        /// </summary>
        [NotNull]
        public FitnessDelegate FitnessFunction { get; }

        /// <summary>
        /// Gets or sets the callback action used to report the progress
        /// </summary>
        [CanBeNull]
        public IProgress<GeneticAlgorithmProgress> ProgressCallback { get; set; }

        /// <summary>
        /// Gets the number of the current generation since the provider instance was created
        /// </summary>
        public int Generation { get; private set; }

        /// <summary>
        /// Gets whether or not the provider instance is currently running the genetic algorithm
        /// </summary>
        public bool IsRunning => _Cts != null;

        #endregion

        #region Working set fields

        /// <summary>
        /// Gets the random instance used in the genetic algorithm
        /// </summary>
        private readonly Random RandomProvider = new Random();

        /// <summary>
        /// Gets the current population for the genetic algorithm
        /// </summary>
        private NeuralNetwork[] _Population;


        /// <summary>
        /// Gets the semaphore used to synchronize the genetic algorithm execution
        /// </summary>
        private readonly SemaphoreSlim RunningSemaphore = new SemaphoreSlim(1);

        /// <summary>
        /// Gets the cacellation token to stop the genetic algorithm
        /// </summary>
        private CancellationTokenSource _Cts;

        #endregion

        #region Best network

        private (NeuralNetwork, float) _BestResult;

        /// <summary>
        /// Gets or sets the current best result produced by the genetic algorithm
        /// </summary>
        private (NeuralNetwork Network, float Fitness) BestResult
        {
            get => _BestResult;
            set
            {
                (_, float previous) = _BestResult;
                (_, float next) = value;
                if (next > previous)
                {
                    _BestResult = value;
                    BestNetworkChanged?.Invoke(this, new GeneticAlgorithmBestNetworkChangedEventArgs(value.Network, value.Fitness));
                }
            }
        }

        /// <summary>
        /// Gets the maximum fitness score reached by the provider instance
        /// </summary>
        [PublicAPI]
        public float BestFitness => BestResult.Fitness;

        /// <summary>
        /// Gets the current best network generated by the provider
        /// </summary>
        [PublicAPI]
        [CanBeNull]
        public INeuralNetwork BestNetwork => BestResult.Network;

        /// <summary>
        /// Callback called whenever the genetic algorithm produces a better neural network for the current fitness function
        /// </summary>
        public event EventHandler<GeneticAlgorithmBestNetworkChangedEventArgs> BestNetworkChanged;

        #endregion

        #region Initialization

        // Private constructor
        private NeuralNetworkGeneticAlgorithmProvider(
            [NotNull] FitnessDelegate fitnessFunction, 
            int populationSize, int weightsMutationRate, int eliteSamples, 
            [NotNull] NeuralNetwork network)
        {
            // Input checks
            if (populationSize <= 0) throw new ArgumentOutOfRangeException("The population must have at least one element");
            if (weightsMutationRate <= 0 || weightsMutationRate > 99) throw new ArgumentOutOfRangeException("The mutation rate must be between 0 and 100");
            if (eliteSamples < 0 || eliteSamples >= populationSize)
            {
                throw new ArgumentOutOfRangeException("The number of elite samples must be a positive number less than or equal to the population size");
            }

            // Assign the fields
            FitnessFunction = fitnessFunction ?? throw new ArgumentNullException("The fitness function can't be null");
            WeightsMutationRate = weightsMutationRate;
            EliteSamples = eliteSamples;

            // Initialization
            BestResult = (network, fitnessFunction(network.GetHashCode(), network.Forward, new List<ForwardFunction>()));
        }

        /// <summary>
        /// Creates a new provider instance with no hidden layers
        /// </summary>
        /// <param name="fitnessFunction">The fitness function used to evaluate the neural networks</param>
        /// <param name="populationSize">Number of networks in the population</param>
        /// <param name="weightsMutationRate">Probability for each weight mutation</param>
        /// <param name="eliteSamples">Number of best networks to copy in each generation</param>
        /// <param name="layers">The desired network layers</param>
        [PublicAPI]
        [Pure, ItemNotNull]
        public static Task<NeuralNetworkGeneticAlgorithmProvider> NewNetworkProviderAsync(
            [NotNull] FitnessDelegate fitnessFunction, 
            int populationSize, int weightsMutationRate, int eliteSamples, 
            [NotNull, ItemNotNull] params NetworkLayer[] layers)
        {
            return Task.Run(() =>
            {
                NeuralNetwork network = NeuralNetwork.NewRandom(layers);
                NeuralNetworkGeneticAlgorithmProvider provider = new NeuralNetworkGeneticAlgorithmProvider(fitnessFunction, populationSize, weightsMutationRate, eliteSamples, network);
                NeuralNetwork[] population = new NeuralNetwork[populationSize];
                population[0] = network;
                for (int i = 1; i < populationSize; i++)
                    population[i] = NeuralNetwork.NewRandom(layers);
                return provider;
            });
        }

        /// <summary>
        /// Creates a new instance from a serialized neural network
        /// </summary>
        /// <param name="fitnessFunction">The fitness function used to evaluate the neural networks</param>
        /// <param name="network">The neural network to use to initialize the provider</param>
        /// <param name="population">Number of networks in the population</param>
        /// <param name="weightsMutationRate">Probability for each weight mutation</param>
        /// <param name="eliteSamples">Number of best networks to copy in each generation</param>
        [PublicAPI]
        [Pure, ItemNotNull]
        public static Task<NeuralNetworkGeneticAlgorithmProvider> FromNetworkAsync(
            FitnessDelegate fitnessFunction, INeuralNetwork network,
            int population, int weightsMutationRate, int eliteSamples)
        {
            // Execute the function on a background thread
            return Task.Run(() =>
            {
                // Reconstruct the original data
                if (!(network is NeuralNetwork nn)) throw new ArgumentException(nameof(network), "Invalid network type");
                NeuralNetworkGeneticAlgorithmProvider provider = new NeuralNetworkGeneticAlgorithmProvider(fitnessFunction, population, weightsMutationRate, eliteSamples, nn);
                NeuralNetwork[] initialPopulation = new NeuralNetwork[population];
                initialPopulation[0] = nn;
                for (int i = 1; i < population - 1; i++)
                    initialPopulation[i] = MutateNetwork(nn);
                provider._Population = initialPopulation;
                return provider;
            });
        }

        #endregion

        #region Public methods

        /// <summary>
        /// Starts the provider, returns true if the operation is successful
        /// </summary>
        [PublicAPI]
        public async Task<bool> StartAsync()
        {
            // Wait and check the current status
            await RunningSemaphore.WaitAsync();
            if (_Cts != null)
            {
                RunningSemaphore.Release();
                return false;
            }

            // Start the genetic algorithm
            _Cts = new CancellationTokenSource();
            BreedNetworks(_Cts.Token);
            RunningSemaphore.Release();
            return true;
        }

        /// <summary>
        /// Stops the provider, returns false if it wasn't running when the method was called
        /// </summary>
        [PublicAPI]
        public async Task<bool> StopAsync()
        {
            // Wait and check if the provider was running
            await RunningSemaphore.WaitAsync();
            if (_Cts == null)
            {
                RunningSemaphore.Release();
                return false;
            }

            // Stop the genetic algorithm
            _Cts.Cancel();
            _Cts = null;
            RunningSemaphore.Release();
            return true;
        }

        #endregion

        #region Genetic algorithm

        /// <summary>
        /// Returns a new mutated network from the input network
        /// </summary>
        /// <param name="network">The input network</param>
        [NotNull]
        private static NeuralNetwork MutateNetwork([NotNull] NeuralNetwork network)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Runs the genetic algorithm
        /// </summary>
        /// <param name="token">The cancellation token for the algorithm</param>
        private async void BreedNetworks(CancellationToken token)
        {
            // Loop until the token is cancelled
            while (!token.IsCancellationRequested)
            {
                // Test the current generation
                IEnumerable<Task<(NeuralNetwork, float)>> testing = _Population.Select(async (net, i) =>
                {
                    IEnumerable<ForwardFunction> opponents = _Population.Where((entry, pos) => pos != i).Select<NeuralNetwork, ForwardFunction>(entry => entry.Forward);
                    float fitness = await Task.Run(() => FitnessFunction(net.GetHashCode(), net.Forward, opponents), token);
                    return (net, fitness);
                });
                (NeuralNetwork, float)[] result = await Task.WhenAll(testing);

                // Iterate over all the results
                float tot = 0;
                (NeuralNetwork, float) bestResult = (null, 0);
                foreach ((NeuralNetwork net, float score) in result)
                {
                    // Get the best score and the total
                    (NeuralNetwork previous, float previousScore) = bestResult;
                    if (previous == null || score > previousScore)
                    {
                        bestResult = (net, score);
                    }
                    tot += score;
                }
                if (bestResult.Item1 == null) throw new InvalidOperationException();
                if (bestResult.Item2 > BestFitness) BestResult = bestResult;

                // Invoke the callback if possible
                ProgressCallback?.Report(new GeneticAlgorithmProgress(Generation, bestResult.Item2, tot / PopulationSize, BestFitness));
                Generation++;

                // Iterate over the results and populate the mating pool
                (NeuralNetwork, float)[] matingPool = new (NeuralNetwork, float)[PopulationSize];
                for (int i = 0; i < PopulationSize; i++)
                {
                    // Pick a random mate
                    int b;
                    do
                    {
                        b = RandomProvider.Next(PopulationSize);
                    } while (i == b);

                    // Add the best one to the pool
                    matingPool[i] = result[i].Item2 > result[b].Item2 ? result[i] : result[b];
                }

                // Initialize the children list and select the elite
                List<NeuralNetwork> children = new List<NeuralNetwork>();
                children.AddRange(matingPool.OrderByDescending(r => r.Item2).Take(EliteSamples).Select(r => r.Item1));

                // Filter the mating pool to skip the worst results
                NeuralNetwork[] filtered = matingPool.OrderBy(r => r.Item2).Skip(EliteSamples).Select(r => r.Item1).ToArray();
                for (int i = 0; i < filtered.Length; i++)
                {
                    // Select the parents for the new child
                    int a, b;
                    do
                    {
                        a = RandomProvider.Next(filtered.Length);
                        b = RandomProvider.Next(filtered.Length);
                    } while (a == b);

                    // Two points crossover
                    children.Add(filtered[a].Crossover(filtered[b], RandomProvider));
                }
                if (children.Count != PopulationSize) Debugger.Break();

                // Queue and run all the current mutation
                IEnumerable<Task<NeuralNetwork>> mutation = children.Select(child => Task.Run(() => MutateNetwork(child), token));
                _Population = await Task.WhenAll(mutation);
            }
        }

        #endregion
    }
}
